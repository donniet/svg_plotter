#version 300 es
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer

in vec2 a_position;

out vec2 pos;
out vec4 col;

uniform mat3 u_view;
uniform vec2 u_range;

uniform vec4 u_stop_colors[STOPS];
uniform float u_stop_offsets[STOPS];
uniform vec2 u_linear_gradient[2];

// TODO: can't use these to switch since our defines are added to the top
#define COLOR_SPACE_HSL 1
#define COLOR_SPACE_RGB 2


/* from: https://github.com/Experience-Monks/glsl-hsl2rgb/blob/master/index.glsl */
float hue2rgb(float f1, float f2, float hue) {
    if (hue < 0.0)
        hue += 1.0;
    else if (hue > 1.0)
        hue -= 1.0;
    float res;
    if ((6.0 * hue) < 1.0)
        res = f1 + (f2 - f1) * 6.0 * hue;
    else if ((2.0 * hue) < 1.0)
        res = f2;
    else if ((3.0 * hue) < 2.0)
        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
    else
        res = f1;
    return res;
}

vec3 hsl2rgb(vec3 hsl) {
    vec3 rgb;
    
    if (hsl.y == 0.0) {
        rgb = vec3(hsl.z); // Luminance
    } else {
        float f2;
        
        if (hsl.z < 0.5)
            f2 = hsl.z * (1.0 + hsl.y);
        else
            f2 = hsl.z + hsl.y - hsl.y * hsl.z;
            
        float f1 = 2.0 * hsl.z - f2;
        
        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
        rgb.g = hue2rgb(f1, f2, hsl.x);
        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
    }   
    return rgb;
}

vec3 hsl2rgb(float h, float s, float l) {
    return hsl2rgb(vec3(h, s, l));
}


vec4 gradient_color(vec2 pos)
{
    // is this actually a gradient?
#if !defined(STOPS) || STOPS == 0
    return u_fill_color;
#elif STOPS == 1
    return u_stop_colors[0];
#else
    vec2 g = u_linear_gradient[1] - u_linear_gradient[0];

    float p = dot(pos - u_linear_gradient[0], g);
    p /= dot(g, g);

    if(p < 0. || p > 1.)
        p = mod(p, 1.);

    int stop = 0;
    for(; stop < STOPS - 1; stop++)
        if(p >= u_stop_offsets[stop] && p < u_stop_offsets[stop+1])
            break;

    // switch(stop)
    // {
    //     case 0: return vec4(1,0,0,1);
    //     case 1: return vec4(0,1,0,1);
    //     case 2: 
    //     default:
    //         return vec4(0,0,1,1);
    // }


    float q = (p - u_stop_offsets[stop]) / (u_stop_offsets[stop+1] - u_stop_offsets[stop]);

    // vec4 c0 = vec4(hsl2rgb(u_stop_colors[stop].xyz), u_stop_colors[stop].w);
    // vec4 c1 = vec4(hsl2rgb(u_stop_colors[stop+1].xyz), u_stop_colors[stop+1].w);
    vec4 c0 = u_stop_colors[stop];
    vec4 c1 = u_stop_colors[stop+1];

    vec4 c = c0 + q * (c1 - c0);


    // c = u_stop_colors[stop];

    // #if COLOR_SPACE == COLOR_SPACE_HSL
        c.rgb = hsl2rgb(c.xyz);
    // #endif

    return c;
#endif
}

// all shaders have a main function
void main() 
{
    // gl_Position is a special variable a vertex shader
    // is responsible for setting
    vec2 p = a_position;
    pos = a_position;

    col = gradient_color(pos);

    p.x = dot(u_view[0].xy, a_position.xy) + u_view[0][2];
    p.y = dot(u_view[1].xy, a_position.xy) + u_view[1][2];

    gl_Position = vec4(p.xy, 0, 1.);
}